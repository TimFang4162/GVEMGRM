% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gvemgrm.R
\name{gvemgrm}
\alias{gvemgrm}
\title{GVEM algorithm for MGRM}
\usage{
gvemgrm(
  y,
  init_A,
  init_B = NULL,
  init_sig = NULL,
  init_ksi1 = NULL,
  init_ksi2 = NULL,
  tar_mod = NULL,
  is_sigmaknown = 0,
  maxiter = 200,
  tol_n2vlb = 1e-04,
  tol_para = 0.001,
  stop_cri = 2,
  calcu_n2vlb = 0
)
}
\arguments{
\item{y}{N*J mat, graded item responses.}

\item{init_A}{J*K mat, initial value of A.}

\item{init_B}{J*R vec, initial value of B.}

\item{init_sig}{K*K mat, initial value of \eqn{\Sigma}.}

\item{init_ksi1}{N*J mat, initial value of \eqn{\xi_{1}}, the variational parameter.}

\item{init_ksi2}{N*J mat, initial value of \eqn{\xi_{2}}, the variational parameter.}

\item{tar_mod}{J*K mat, target model (structure of A), the element only 0 or 1 is valid.}

\item{is_sigmaknown}{default is 0, meaning \eqn{\Sigma} is unknown and will be estimated; 1 means \eqn{\Sigma} is known and fixed.}

\item{maxiter}{maximum number of iterations. default is 100.}

\item{tol_n2vlb}{tolerance for convergence of the variational lower bound, default is 1e-4.}

\item{tol_para}{tolerance for convergence of parameters, default is 1e-3.}

\item{stop_cri}{stopping criterion: 1 for variational lower bound, 2 for parameter changes.}

\item{calcu_n2vlb}{whether to calculate the variational lower bound in each iteration when stop.cri = 2, default is 0.}
}
\value{
A list contains:
  \tabular{ll}{
    \code{new_A} \tab estimated A (slope parameters).\cr
    \code{new_B} \tab estimated B (threshold parameters).\cr
    \code{new_Sig} \tab estimated \eqn{\Sigma} (correlation of latent traits).\cr
    \code{new_ksi1} \tab variational parameters \eqn{\xi_1}.\cr
    \code{new_ksi2} \tab variational parameters \eqn{\xi_2}.\cr
    \code{mu_n} \tab parameter \eqn{\mu_i} of Gaussian variational distribution \eqn{q_i(\theta_i)} for all \eqn{i=1,\ldots,N}.\cr
    \code{sigma_n} \tab parameter \eqn{\Sigma_i} of Gaussian variational distribution \eqn{q_i(\theta_i)} for all \eqn{i=1,\ldots,N}.\cr
    \code{n2vlb} \tab negative twice the evidence lower bound (ELBO).\cr
    \code{vbic} \tab variational BIC.\cr
    \code{n2vlb_seq} \tab negative twice the ELBO at each iteration, returns NA when stop_cri = 2 and calcu_n2vlb = 0.\cr
    \code{iter} \tab number of iterations.\cr
    \code{converge_n2vlb} \tab indicates ELBO convergence status for stop_cri = 1, 1 if converged, 0 otherwise.\cr
    \code{converge_para} \tab indicates parameters convergence status for stop_cri = 2, 1 if converged, 0 otherwise.\cr
    \code{cpu_time} \tab computing time.\cr
  }
}
\description{
Gaussian variational expectation maximization algorithm for estimating 
item parameters in multidimensional graded response model.
}
\examples{
# ------------------------------------------
# -- An example for Confirmatory Analysis --
# ------------------------------------------
library(GVEMGRM)
attach(toy_data) # load true parameters & graded response data y

# -- initial parameters --
# -- note that, the initial value of B, Sig and variational parameters are unnecessary
N <- nrow(y)
J <- ncol(y)
K <- 2

model  <- (true_A!=0)*1
init_A <- matrix(.01, nrow=J, ncol=K); init_A[model==0] <- 0

# -- call gvemgrm --
output <- gvemgrm(y = y, init_A = init_A, tar_mod = model)
names(output)
output$new_A


# ------------------------------------------
# -- An example for Exploratory Analysis ---
# ------------------------------------------

# -- note that, the key for exploratory analysis is
# -- 1. set the target model as full model.
# -- 2. keep Sigma as identity matrix, i.e., set init_Sig = diag(1,K) and is_sigmaknown = 1. 
# -- 3. to avoid numerical error, set random value for initial value of A.
# -- factor rotation technique may cause the column swapping.
library(GVEMGRM)
library(GPArotation)
attach(toy_data)

# -- initial parameters --
N <- nrow(y)
J <- ncol(y)
K <- 2

set.seed(627)
model  <- matrix(1,J,K)
init_A <- matrix(runif(J*K,.01,.02), nrow=J, ncol=K)
init_Sig <- diag(1,K)

# -- call gvemgrm --
output <- gvemgrm(y = y, init_A = init_A, tar_mod = model, is_sigmaknown = 1)
esti_A <- output$new_A
fa_rot <- quartimin(esti_A) # oblique rotation
rot_A   <- fa_rot$loadings
rot_Sig <- fa_rot$Phi
cut_A <- rot_A
cut_A[abs(rot_A)<.3] <- 0

rot_A
cut_A
rot_Sig


}
